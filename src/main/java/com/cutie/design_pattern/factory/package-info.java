/**
 * Created by cutie on 2017/11/18.
 */
package com.cutie.design_pattern.factory;

/*
* http://www.jianshu.com/p/bf8341c75304
*
* 简单工厂 ： 产品共同继承一个接口
*
* 简单工厂模式的适用环境
（1）工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂；
（2）客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。
* 1、直接判断传入的key
*   这样的实现有个问题，如果我们新增产品类的话，需要不断的在工厂类中新增case，这样需要修改的地方比较多，
*   所以不建议使用这样的方法来实现工厂类。
*
* 2、利用反射
*       Product product = (Product) Class.forName(className).newInstance();
*   这种的缺点在于，每次创建一个产品时，需要传入产品的全部类路径，也就是要记住一个产品的全部路径，
*   比较麻烦。我们想到可以通过配置文件，来将类路径全部写在properties文件中，通过加载配置文件，
*   这样如果以后新增的话，直接修改配置文件即可。
*
* 3、反射加配置文件
*
* 工厂模式 ： 工厂共同继承一个工厂接口，产品共同继承一个产品接口 ，工厂返回特定的产品
*
* 工厂方法模式的适用环境
在以下情况下可以使用工厂方法模式：
（1）一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。
（2）一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。
（3）将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无需关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。
*
* 抽象工厂模式  工厂共同继承一个工厂接口，多个产品共继承多个产品接口 ，不同工厂调用不同的生产方法生成不同的产品（同一个接口）
*
* 抽象工厂模式的适用环境
（1）一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节。这对于所有形态的工厂模式都是重要的；
（2）一个系统的产品有多于一个的产品族，而系统只消费其中某一族的产品；
（3）同属于同一个产品族的产品是在一起使用的，这一约束必须要在系统的设计中体现出来；
（4）系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现。
*
* 总结：
*（1）简单工厂模式是由一个具体的类去创建其他类的实例，父类是相同的，父类是具体的。
（2）工厂方法模式是有一个抽象的父类定义公共接口，子类负责生成具体的对象，这样做的目的是将类的实例化操作延迟到子类中完成。
（3）抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定他们具体的类。它针对的是有多个产品的等级结构。而工厂方法模式针对的是一个产品的等级结构。
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
* */